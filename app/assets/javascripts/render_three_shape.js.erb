function inchesToPixels(inches) {
    return inches * 100;
}

function pixelsToInches(pixels) {
    return pixels / 100.0;
}

function render_three_shape(vue_data) {

    var container;
    var camera, scene, renderer, controls, width, height;
    init();
    animate();

    function init() {

        //console.log(vue_data);

        width = $("#weld-render-view").width();
        height = width * 0.75;
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor( 0x222222 );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( width, height );
        $("#weld-render-view").html( renderer.domElement );
        scene = new THREE.Scene();
        var aspectRatio = width / height;
        camera = new THREE.PerspectiveCamera( 45, aspectRatio * 1.2, 1, 1000 );
        camera.position.set( 0, 0, 1500 );

        // Controls for Orthographic camera (trackball controls are wonky though)
        //var viewSize = 900;
        // OrthographicCamera( left, right, top, bottom, near, far)
        //camera = new THREE.OrthographicCamera( -aspectRatio*viewSize/2, aspectRatio*viewSize/2, viewSize/2, -viewSize/2, -1000, 1000 );
        //camera.position.set( 20, 20, 20 ); // all components equal
        //camera.lookAt( scene.position ); // or the origin
        // controls = new THREE.OrthographicTrackballControls( camera, renderer.domElement );

        controls = new THREE.TrackballControls( camera, renderer.domElement );
        controls.minDistance = 200;
        controls.maxDistance = 500;
        var ambientlight = new THREE.AmbientLight( 0xffffff );
        ambientlight.intensity = 0.6;
        scene.add( ambientlight );
        var light = new THREE.PointLight( 0xffffff );
        light.position.copy( camera.position );
        scene.add( light );


        switch(vue_data.dimension_data.selected) {
            case 'plate':
                buildPlate(vue_data, scene);
                break;
            case 'pipe':
                buildPipe(vue_data, scene);
                break;
            case 't_pipe':
                buildTeePipe(vue_data, scene);
                break;
            case 'lap_joint':
                buildLapJoint(vue_data, scene);
                break;
            case 't_plate':
                buildTeeJoint(vue_data, scene);
                break;
            default:
                buildPlate(vue_data, scene);
        }

    }

    function buildPlate(vue_data, scene) {
        // Plate
        var plate_data = vue_data.dimension_data.fixture_shapes.find(function (shape) {
            return shape.value === 'plate';
        }, this);

        var width = inchesToPixels(plate_data.dimensions.width_w1);
        var height = inchesToPixels(plate_data.dimensions.thickness);
        var depth = inchesToPixels(plate_data.dimensions.length);
        var material = new THREE.MeshLambertMaterial({color: '#a8b2c1', map: new THREE.TextureLoader().load( "<%= asset_path 'metal.png' %>" )});
        var cube = new THREE.CubeGeometry(width, height, depth);
        cube = new THREE.Mesh( cube, material );
        cube.position.set(width * 0.5, height, 0);
        scene.add(cube);
        var cube2 = new THREE.CubeGeometry(width, height, depth);
        cube2 = new THREE.Mesh( cube2, material );
        cube2.position.set(-(width * 0.5), height, 0);
        scene.add(cube2);
    }

    function buildLapJoint(vue_data, scene) {
        // Lap Joint
        var width = 300;
        var height = 10;
        var depth = 250;
        var material = new THREE.MeshLambertMaterial({color: '#a8b2c1', map: new THREE.TextureLoader().load( "<%= asset_path 'metal.png' %>" )});
        var cube = new THREE.CubeGeometry(width, height, depth);
        cube = new THREE.Mesh( cube, material );
        cube.position.set(width * 0.25, -(height * 0.5), 0);
        scene.add(cube);
        var cube2 = new THREE.CubeGeometry(width, height, depth);
        cube2 = new THREE.Mesh( cube2, material );
        cube2.position.set(-(width * 0.25), height * 0.5, 0);
        scene.add(cube2);
    }

    function buildTeeJoint(vue_data, scene) {
        // Tee Joint
        var width = 300;
        var height = 10;
        var depth = 250;
        var tee_width = 20;
        var tee_height = 50;

        var material = new THREE.MeshLambertMaterial({color: '#a8b2c1', map: new THREE.TextureLoader().load( "<%= asset_path 'metal.png' %>" )});
        var cube = new THREE.CubeGeometry(width, height, depth);
        cube = new THREE.Mesh( cube, material );
        cube.position.set(0, 0, 0);
        scene.add(cube);
        var cube2 = new THREE.CubeGeometry(tee_width, tee_height, depth);
        cube2 = new THREE.Mesh( cube2, material );
        cube2.position.set(0, (height / 2.0) + (tee_height / 2.0), 0);
        scene.add(cube2);
    }

    function buildPipe(vue_data, scene) {
        // Tee Joint
        var outer_diameter = 300;
        var wall_thickness = 100;
        var length = 250;

        var material = new THREE.MeshLambertMaterial({color: '#a8b2c1', map: new THREE.TextureLoader().load( "<%= asset_path 'metal.png' %>" )});

        /*
            CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength)

                radiusTop — Radius of the cylinder at the top. Default is 20.
                radiusBottom — Radius of the cylinder at the bottom. Default is 20.
                height — Height of the cylinder. Default is 100.
                radiusSegments — Number of segmented faces around the circumference of the cylinder. Default is 8
                heightSegments — Number of rows of faces along the height of the cylinder. Default is 1.
                openEnded — A Boolean indicating whether the ends of the cylinder are open or capped. Default is false, meaning capped.
                thetaStart — Start angle for first segment, default = 0 (three o'clock position).
                thetaLength — The central angle, often called theta, of the circular sector. The default is 2*Pi, which makes for a complete cylinder.
         */
        var cube = new THREE.CylinderGeometry(50, 50, 200, 320);
        cube = new THREE.Mesh( cube, material );
        cube.position.set(0, 0, 0);
        scene.add(cube);
    }

    function buildTeePipe(vue_data, scene) {
        // Tee Joint
        var outer_diameter = 300;
        var wall_thickness = 100;
        var length = 250;

        var outer_diameter_tee = 500;
        var wall_thickness_tee = (outer_diameter_tee - outer_diameter) / 2;
        var length_tee = 50;

        var material = new THREE.MeshLambertMaterial({color: '#a8b2c1', map: new THREE.TextureLoader().load( "<%= asset_path 'metal.png' %>" )});

        /*
            CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength)

                radiusTop — Radius of the cylinder at the top. Default is 20.
                radiusBottom — Radius of the cylinder at the bottom. Default is 20.
                height — Height of the cylinder. Default is 100.
                radiusSegments — Number of segmented faces around the circumference of the cylinder. Default is 8
                heightSegments — Number of rows of faces along the height of the cylinder. Default is 1.
                openEnded — A Boolean indicating whether the ends of the cylinder are open or capped. Default is false, meaning capped.
                thetaStart — Start angle for first segment, default = 0 (three o'clock position).
                thetaLength — The central angle, often called theta, of the circular sector. The default is 2*Pi, which makes for a complete cylinder.
         */
        var inner_pipe = new THREE.CylinderGeometry(50, 50, 200, 320);
        inner_pipe = new THREE.Mesh( inner_pipe, material );
        inner_pipe.position.set(0, 0, 0);
        scene.add(inner_pipe);

        var outer_pipe = new THREE.CylinderGeometry(70, 70, 40, 320);
        outer_pipe = new THREE.Mesh( outer_pipe, material );
        outer_pipe.position.set(0, 0, 0);
        scene.add(outer_pipe);
    }

    function animate() {
        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene, camera );
    }
}
