function inchesToPixels(inches) {
    return inches * 100;
}

function pixelsToInches(pixels) {
    return pixels / 100.0;
}

// Global variables
var renderer;
var scene;
var camera;
var controls;
var material;

function init_three() {

    var width, height;

    width = $("#weld-render-view").width();
    height = width * 0.75;
    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor( 0x222222 );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( width, height );
    $("#weld-render-view").html( renderer.domElement );
    scene = new THREE.Scene();
    var aspectRatio = width / height;
    camera = new THREE.PerspectiveCamera( 45, aspectRatio * 1.2, 1, 10000 );
    camera.position.set( 0, 0, 2000 );

    controls = new THREE.TrackballControls( camera, renderer.domElement );
    controls.minDistance = 100;
    controls.maxDistance = 10000;
    var ambientlight = new THREE.AmbientLight( 0xffffff );
    ambientlight.intensity = 0.6;
    scene.add( ambientlight );
    var light = new THREE.PointLight( 0xffffff );
    light.position.copy( camera.position );
    scene.add( light );

    material = new THREE.MeshLambertMaterial({color: '#a8b2c1', map: new THREE.TextureLoader().load( "<%= asset_path 'metal.png' %>" )});
}

// Reset the view to the default state
function reset_camera() {
    if (controls !== undefined) {
        controls.reset();
        animate();
    }
}

function render_three_shape(vue_data) {

    if (scene === undefined) {
        // Initialize the scene and objects on first run.
        init_three();
    } else {
        // If the scene has already been defined, remove the existing meshes.
        for (var i = scene.children.length - 1; i >= 0; i--) {
            if (scene.children[i].isMesh) {
                scene.children.splice(i, 1);
            }
        }
    }

    // Don't show a root gap when bead on plate selected
    if (vue_data.joint_data.selected === 'bead_on_plate') {
        vue_data.joint_data.root_gap.present = false;
    }

    switch(vue_data.dimension_data.selected) {
        case 'plate':
            buildPlate(vue_data, scene);
            animate();
            break;
        case 'pipe':
            buildPipe(vue_data, scene);
            animate();
            break;
        case 't_pipe':
            buildTeePipe(vue_data, scene);
            animate();
            break;
        case 'lap_joint':
            buildLapJoint(vue_data, scene);
            animate();
            break;
        case 't_plate':
            buildTeeJoint(vue_data, scene);
            animate();
            break;
        default:
            buildPlate(vue_data, scene);
            animate();
    }

    function buildPlate(vue_data, scene) {
        // Plate
        var plate_data = vue_data.dimension_data.fixture_shapes.find(function (shape) {
            return shape.value === 'plate';
        }, this);

        // dimensions: {
        //    width_w1: 12,
        //    width_w2: 12,
        //    thickness: 0.5,
        //    length: 4
        //}
        var width_w1 = inchesToPixels(plate_data.dimensions.width_w1);
        var width_w2 = inchesToPixels(plate_data.dimensions.width_w2);
        var height = inchesToPixels(plate_data.dimensions.thickness);
        var depth = inchesToPixels(plate_data.dimensions.length);
        var root_gap = vue_data.joint_data.root_gap.present ? inchesToPixels(vue_data.joint_data.root_gap.range) : 0;

        var cube = new THREE.CubeGeometry(width_w1, height, depth);
        cube = new THREE.Mesh( cube, material );
        cube.position.set((-(width_w1 * 0.5) - (root_gap * 0.5)), height, 0);
        scene.add(cube);
        var cube2 = new THREE.CubeGeometry(width_w2, height, depth);
        cube2 = new THREE.Mesh( cube2, material );
        cube2.position.set((width_w2 * 0.5) + (root_gap * 0.5), height, 0);
        scene.add(cube2);
    }

    function buildLapJoint(vue_data, scene) {
        // Lap Joint
        var lap_joint_data = vue_data.dimension_data.fixture_shapes.find(function (shape) {
            return shape.value === 'lap_joint';
        }, this);

        //dimensions: {
        //    thickness_t1: 0.5,
        //    thickness_t2: 0.5,
        //    width_w1: 6,
        //    width_w2: 6,
        //    overlap: 0.5,
        //    length: 20
        //}
        var width_w1 = inchesToPixels(lap_joint_data.dimensions.width_w1);
        var width_w2 = inchesToPixels(lap_joint_data.dimensions.width_w2);
        var height_t1 = inchesToPixels(lap_joint_data.dimensions.thickness_t1);
        var height_t2 = inchesToPixels(lap_joint_data.dimensions.thickness_t2);
        var overlap = inchesToPixels(lap_joint_data.dimensions.overlap);
        var depth = inchesToPixels(lap_joint_data.dimensions.length);
        var root_gap = vue_data.joint_data.root_gap.present ? inchesToPixels(vue_data.joint_data.root_gap.range) : 0;

        var cube = new THREE.CubeGeometry(width_w1, height_t1, depth);
        cube = new THREE.Mesh( cube, material );
        cube.position.set((width_w1 * 0.5) - (overlap * 0.5), (-(height_t1 * 0.5) - (root_gap * 0.5)), 0);
        scene.add(cube);
        var cube2 = new THREE.CubeGeometry(width_w2, height_t2, depth);
        cube2 = new THREE.Mesh( cube2, material );
        cube2.position.set(-((width_w2 * 0.5) - (overlap * 0.5)), ((height_t2 * 0.5) + (root_gap * 0.5)), 0);
        scene.add(cube2);
    }

    function buildTeeJoint(vue_data, scene) {
        // Tee Joint
        var tee_joint_data = vue_data.dimension_data.fixture_shapes.find(function (shape) {
            return shape.value === 't_plate';
        }, this);

        //dimensions: {
        //    thickness_t1: 0.5,
        //    thickness_t2: 0.5,
        //    width_w1: 6,
        //    width_w2: 6,
        //    length_l: 20,
        //    height_h: 4
        //}
        var thickness_t1 = inchesToPixels(tee_joint_data.dimensions.thickness_t1);
        var thickness_t2 = inchesToPixels(tee_joint_data.dimensions.thickness_t2);
        var width_w1 = inchesToPixels(tee_joint_data.dimensions.width_w1);
        var width_w2 = inchesToPixels(tee_joint_data.dimensions.width_w2);
        var length = inchesToPixels(tee_joint_data.dimensions.length_l);
        var height = inchesToPixels(tee_joint_data.dimensions.height_h);
        var root_gap = vue_data.joint_data.root_gap.present ? inchesToPixels(vue_data.joint_data.root_gap.range) : 0;

        var cube = new THREE.CubeGeometry(width_w1 + width_w2, thickness_t1, length);
        cube = new THREE.Mesh( cube, material );
        cube.position.set((width_w2 * 0.5) - (width_w1 * 0.5), (-(thickness_t1 * 0.5) - (root_gap * 0.5)), 0);
        scene.add(cube);
        var cube2 = new THREE.CubeGeometry(thickness_t2, height, length);
        cube2 = new THREE.Mesh( cube2, material );
        cube2.position.set(0, (height * 0.5) + (root_gap * 0.5), 0);
        scene.add(cube2);
    }

    function buildPipe(vue_data, scene) {

        // Pipe
        var pipe_data = vue_data.dimension_data.fixture_shapes.find(function (shape) {
            return shape.value === 'pipe';
        }, this);

        //dimensions: {
        //    outer_diameter: 36,
        //    wall_thickness: 1,
        //    length_w1: 16,
        //    length_w2: 16
        //}
        var outer_diameter = inchesToPixels(pipe_data.dimensions.outer_diameter);
        var wall_thickness = inchesToPixels(pipe_data.dimensions.wall_thickness);
        var length_w1 = inchesToPixels(pipe_data.dimensions.length_w1);
        var length_w2 = inchesToPixels(pipe_data.dimensions.length_w2);
        var root_gap = vue_data.joint_data.root_gap.present ? inchesToPixels(vue_data.joint_data.root_gap.range) : 0;

        /*
            CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength)

                radiusTop — Radius of the cylinder at the top. Default is 20.
                radiusBottom — Radius of the cylinder at the bottom. Default is 20.
                height — Height of the cylinder. Default is 100.
                radiusSegments — Number of segmented faces around the circumference of the cylinder. Default is 8
                heightSegments — Number of rows of faces along the height of the cylinder. Default is 1.
                openEnded — A Boolean indicating whether the ends of the cylinder are open or capped. Default is false, meaning capped.
                thetaStart — Start angle for first segment, default = 0 (three o'clock position).
                thetaLength — The central angle, often called theta, of the circular sector. The default is 2*Pi, which makes for a complete cylinder.
         */
        var pipe1 = new THREE.CylinderGeometry(outer_diameter / 2.0, outer_diameter / 2.0, length_w1, 90);
        pipe1 = new THREE.Mesh( pipe1, material );
        pipe1.position.set(0, (length_w1 * 0.5) + (root_gap * 0.5), 0);
        scene.add(pipe1);

        var pipe2 = new THREE.CylinderGeometry(outer_diameter / 2.0, outer_diameter / 2.0, length_w2, 90);
        pipe2 = new THREE.Mesh( pipe2, material );
        pipe2.position.set(0, -(length_w2 * 0.5) + -(root_gap * 0.5), 0);
        scene.add(pipe2);
    }

    function buildTeePipe(vue_data, scene) {
        // Tee Joint
        var outer_diameter = 300;
        var wall_thickness = 100;
        var length = 250;

        var outer_diameter_tee = 500;
        var wall_thickness_tee = (outer_diameter_tee - outer_diameter) / 2;
        var length_tee = 50;

        /*
            CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded, thetaStart, thetaLength)

                radiusTop — Radius of the cylinder at the top. Default is 20.
                radiusBottom — Radius of the cylinder at the bottom. Default is 20.
                height — Height of the cylinder. Default is 100.
                radiusSegments — Number of segmented faces around the circumference of the cylinder. Default is 8
                heightSegments — Number of rows of faces along the height of the cylinder. Default is 1.
                openEnded — A Boolean indicating whether the ends of the cylinder are open or capped. Default is false, meaning capped.
                thetaStart — Start angle for first segment, default = 0 (three o'clock position).
                thetaLength — The central angle, often called theta, of the circular sector. The default is 2*Pi, which makes for a complete cylinder.
         */
        var inner_pipe = new THREE.CylinderGeometry(50, 50, 200, 320);
        inner_pipe = new THREE.Mesh( inner_pipe, material );
        inner_pipe.position.set(0, 0, 0);
        scene.add(inner_pipe);

        var outer_pipe = new THREE.CylinderGeometry(70, 70, 40, 320);
        outer_pipe = new THREE.Mesh( outer_pipe, material );
        outer_pipe.position.set(0, 0, 0);
        scene.add(outer_pipe);
    }
}

function animate() {
    requestAnimationFrame( animate );
    controls.update();
    renderer.render( scene, camera );
}
